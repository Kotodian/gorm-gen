package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io/fs"
	"path/filepath"
	"strings"
)

type Generator struct {
	buf    bytes.Buffer
	files  []string
	output string
}

func (g *Generator) Printf(format string, args ...interface{}) {
	_, _ = fmt.Fprintf(&g.buf, format, args...)
}

// ParseDir 获取该目录下的所有文件
func (g *Generator) ParseDir(dir string) {
	if strings.HasSuffix(dir, ".go") {
		return
	}
	err := filepath.WalkDir(dir, func(path string, d fs.DirEntry, err error) error {
		if !d.IsDir() {
			g.files = append(g.files, path)
		}
		return nil
	})
	if err != nil {
		panic(err)
	}
}

// ParseFile 解析文件获得所有文件里的结构体以及包名称以及生成文件名称
func (g *Generator) ParseFile() ([]*File, error) {
	if len(g.files) == 0 {
		return nil, nil
	}
	files := make([]*File, 0)
	for _, f := range g.files {
		// 解析文件
		file := &File{structs: make([]*Struct, 0)}
		file.name = filename(f)
		fset := token.NewFileSet()
		parse, err := parser.ParseFile(fset, f, nil, 0)
		if err != nil {
			return nil, err
		}
		// 遍历节点
		ast.Inspect(parse, func(node ast.Node) bool {
			switch t := node.(type) {
			case *ast.Package:
				file.pkg = t.Name
			case *ast.TypeSpec:
				structType, ok := t.Type.(*ast.StructType)
				if ok {
					stru := &Struct{}
					stru.name = t.Name.Name
					fields := make([]*Field, 0)
					for _, v := range structType.Fields.List {
						if isGorm(v.Names[0].Name, v.Tag.Value) {
							fields = append(fields, &Field{
								name:   v.Names[0].Name,
								goType: v.Type.(*ast.Ident).Name,
								tag:    v.Tag.Value,
							})
						}
					}
					file.structs = append(file.structs, stru)
				}
			}
			return true
		})
		files = append(files, file)
	}
	return files, nil
}

// buildPrepare 每次生成都需要
func (g *Generator) buildPrepare() {
	pkgName := g.output[strings.LastIndex(g.output, "/")+1:]
	g.Printf("// Code generated by \"gorm-gen\"; DO NOT EDIT.\n")
	g.Printf("\n")
	g.Printf("package %s\n", pkgName)
	g.Printf("imports (\n")
	g.Printf("\"gorm.io/gorm\"\n")
	g.Printf("\"context\"\n")
	g.Printf(")")
	g.Printf("\n")
}
